<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 위 3개의 메타 태그는 *반드시* head 태그의 처음에 와야합니다; 어떤 다른 콘텐츠들은 반드시 이 태그들 *다음에* 와야 합니다 -->
    <title>HTML5&CSS with Javascript</title>

    <link rel="stylesheet" href="custom.css">

  </head>
  <body>
    <section id="section-base" class="section-base">
      <div class="mainContainer">
        <div class="baseTopic">
          <h1>HTML5&CSS with Javascript(5day)</h1>
          <p>기본적인 CSS 및 CSS를 활용한 애니메이션과 Viewport 및 미디어 쿼리를 활용하여 모바일 환경에서도 적절하게 표현되는 반응형 웹 구현하기. 이미 모르는 사람이 없을 정도로 유명한 Bootstrap을 이해하기 위한 내용이므로, 부트스트랩과 같은 CSS 프레임워크는 사용하지 않았다.</p>
          <p>현재 페이지는 Viewport를 활용한 반응형 웹으로 만들어졌다. 아래 버튼은 반응형으로 좌우 margin을 적용하는 버튼입니다. 기본적인 원리는 미디어쿼리를 활용하여 화면 크기에 따라 CSS 클래스의 내용이 달라지게 되어 화면 크기에 따라 CSS 속성들이 적용된다.</p>

          <div class="cssBtnGroup">
            <input id="introBtnAdd" class="btnCenter" type="button" value="CSS적용">
            <input id="introBtnRemove" class="btnCenter" type="button" value="CSS제거">
          </div>

          <div class="sectionDiv">
            <section class="articleSection">
              <h1>CSS 적용시키기</h1>
              <p class="descP">
                 기본적으로 CSS는 스타일태그(style) 안에 정의하여 사용할 수 있다. 보통은 Head태그 안에 태그를 만들어 사용하거나 외부에 CSS 파일을 생성하여 코딩을 한 후 파일을 읽어오는 방식으로 사용된다.
              </p>
              <div class="cssBox">
                <div class="cssBoxDesc">
                  <h3>태그활용</h3>
                  <xmp>
      <style>
        body {
          background-color: #3984EE;
        }
        .TopSection{
          text-align: left;
        }
        .btnCenter{
          text-align: center;
        }
        #sectionDiv {
          border: 2px solid grey;
          border-radius: 4px;
          margin: 1% 1%;
        }
      </style>
                  </xmp>
                </div>
                <div class="cssBoxDesc">
                  <h3>외부 CSS 파일 활용</h3>
                  <xmp>
      css/custom.css 가 있다고 가정

      <!doctype html>
      <html>
      <head>
        <link rel="stylesheet"
              src="css/custm.css">
      </head>
      <body>
      </body>
      </html>
                  </xmp>
                </div>
              </div>
              <br><br>
              <h1>참고 : 선택자(Selector)</h1>
              <p class="descP">
                 CSS코드를 보면 코드의 속성(Attribute)를 정의하기 전에 body, .TopSection, #sectionDiv 등의 이름이 활용된 것을 볼 수 있다. 점(.)은 클래스(class)를 의미하고 우물정자(#)는 태그의 이름(name)을 의미한다.
                즉, 점이나 우물정자 없이 정의하면 태그에 직접 CSS 속성을 정의하게 되고 특정 태그 안에 class를 정의하여 활용하는 경우는 태그의 클래스 속성의 명칭(ClassName)을 .ClassName{} 과같은 형식으로 정의하여 사용할 수 있다.
                Class를 활용할 때의 장점은 같은 내용의 CSS 속성을 여러 번 반복적으로 사용할 수 있다는 것이다. 즉 프로그래밍 언어의 함수처럼 여러 번 호출되어도 무방하다는 뜻이다. 단점이라고 한다면, 적용되는 태그가 많아지면 일일히
                지정해야 하는 번거로움이 생긴다는 것 정도이다.
              </p>
            </section>
          </div>
          <div class="sectionDiv">
            <section class="articleSection">
              <!-- <aside>
                <h1>aside area</h1>
              </aside> -->
              <h1>테이블 형식으로 Div표현하기</h1>
              <p class="descP">반응형으로 각각 설정해둔 CSS 클래스를 적용시킴으로써 아래의 div 덩어리를 테이블처럼 표현하는 것이 가능하다.
                첫째로, <span class="classSpan">cssBox</span> 클래스에서는 <span class="attrSpan">[display:table]</span> 속성을 적용시키고, <span class="classSpan">innerDivRow</span> 클래스는 <span class="attrSpan">[display:table-row]</span> 끝으로 <span class="classSpan">innerDivCell</span> 클래스의 경우는
                <span class="attrSpan">[display:table-cell]</span>을 적용시키면 행과 열로 나누어진 테이블을 div 태그만으로 표현이 가능하다.<br><br>
                현재 반응형으로 스타일을 각각 적용시켜두었기 때문에 PC 화면에서는 2열 4행의 테이블로 보일테지만, 모바일 기기에서는 두서없이 1렬로 나열댄
                div 태그로 보일것이다.
              </p>
              <div>
                  <xmp>
      <div class="cssBox">
        <div class="innerDivRow">
          <div class="innerDivCell">row#1 div#1</div>
          <div class="innerDivCell">row#1 div#2</div>
          <div class="innerDivCell">row#1 div#3</div>
          <div class="innerDivCell">row#1 div#3</div>
        </div>
        <div class="innerDivRow">
          <div class="innerDivCell">row#2 div#1</div>
          <div class="innerDivCell">row#2 div#2</div>
          <div class="innerDivCell">row#2 div#3</div>
          <div class="innerDivCell">row#2 div#3</div>
        </div>
      </div>
                </xmp>
              </div>
              <div class="cssBox">
                <div class="innerDivRow">
                  <div class="innerDivCell">row#1 div#1</div>
                  <div class="innerDivCell">row#1 div#2</div>
                  <div class="innerDivCell">row#1 div#3</div>
                  <div class="innerDivCell">row#1 div#3</div>
                </div>
                <div class="innerDivRow">
                  <div class="innerDivCell">row#2 div#1</div>
                  <div class="innerDivCell">row#2 div#2</div>
                  <div class="innerDivCell">row#2 div#3</div>
                  <div class="innerDivCell">row#2 div#3</div>
                </div>
              </div>
            </section>
          </div>
          <div class="sectionDiv">
            <section class="articleSection">
              <h1>네비게이션바(navbar) 만들기</h1>
              <div class="cssBox">
                <div class="navbar">
                  <ul>
                    <li><a>Home</a></li>
                    <li><a>News</a></li>
                    <li><a>Contact</a></li>
                    <li><a>About</a></li>
                  </ul>
                </div>
              </div>
              <p class="descP">
                원리는 위의 테이블과 유사하지만 테이블 스타일을 활용하지 않고 float속성을 활용한 예이다. ul태그와 li태그에 스타일을 적용하여 표현이 가능하다. 먼저 ul태그에
                <span class="attrSpan">list-style-type: none</span> 속성을 적용시켜 기존 li태그에 나타나는 점을 없애고, <span class="attrSpan">overflow: hidden</span> 속성으로
                혹시나 태그 밖으로 넘치게 표현되는 것들을 화면상에 나타나지 않도록한다.(미적용시 배경색 적용X) 그 다음 li태그에 <span class="attrSpan">float:left</span> 속성을 적용시켜 최대 넓이를 넘지
                않는 선에서 좌측부터 차례대로 나열되도록 한다.
              </p>
              <div class="cssBox">
                <div class="cssBoxDesc">
                  <h3>HTML</h3>
                  <xmp>
      <div class="navbar">
        <ul>
          <li><a>Home</a></li>
          <li><a>News</a></li>
          <li><a>Contact</a></li>
          <li><a>About</a></li>
        </ul>
      </div>
                  </xmp>
                </div>
                <div class="cssBoxDesc">
                  <h3>CSS</h3>
                  <xmp>
        .navbar ul {
          list-style-type: none;
          margin: 0;
          padding: 0;
          overflow: hidden;
          background-color: #333;
        }
        .navbar li {
          float: left;
          width: 25%;
        }
        .navbar li a {
          display: block;
          color: white;
          text-align: center;
          padding: 14px 16px;
          text-decoration: none;
          cursor: pointer;
        }
                  </xmp>
                </div>
              </div>

              <br><br>

              <h1>참고 : CSS hover</h1>
              <p class="descP">
                MouseOver(마우스오버)효과로 해당 목록에 마우스를 가져다 댄 경우 색이 변하는 것을 확인할 수 있다. 이 경우엔 <span class="classSpan">태그명:hover{<span class="attrSpan">background-color: 색상</span>}</span>
                으로 원하는 색상으로 마우스오버시 색상을 변경하는 것이 가능하다.
              </p>

            </section>
          </div>
          <div class="sectionDiv">
            <section class="articleSection">
              <h1>Transition(천이:옮기어 바뀜) 설정하기</h1>
              <p class="descP">
                &nbsp;버튼 클릭이라던지 마우스오버 등의 이벤트가 발생하는 경우 종종 크기가 변한다던지 위치가 변하는 CSS를 본 적이 있을 것이다. 우선 흔히 찾을 수 있는 예제를 보도록 하자.
              </p>
              <div class="cssBox">
                <div class="cssBoxDesc">
                  <h3>hover-Transtion</h3>
                  <div class="exTransition"></div>
                  <p>상자에 마우스오버 하세요!</p>
                  <xmp>
      <div class="exTransition"></div>
                  </xmp>
                </div>
                <div class="cssBoxDesc">
                  <h3>CSS</h3>
                  <xmp>
      .examTransition{
        margin: 10px;
        width: 50px;
        height: 50px;
        transition: 2.0s;
        background-color: red;

      }
      .examTransition:hover{
        width: 93%;
      }
                  </xmp>
                </div>
              </div>
              <p class="descP">
                &nbsp;예제를 보면 알 수 있듯이 트랜지션은 바뀌기 전 클래스에 속성을 부여하였다. 즉 기존에 설정되어있는 트랜지션의 시간에따라 CSS의 내용이 변경되는 적용시키는 시간을 지정해놓는 것이다. 물론 마우스오버시에 길이가 늘어나도록 설정해놓은 것도 확인할 수 있을 것이고, 그 결과를 보고 어떻게 적용되었는지 이해하는 것에
                문제가 없을 것이라 생각한다.
              </p>
            </section>
          </div>
          <div class="sectionDiv">
            <section class="articleSection">
              <h1>Animation</h1>
              <p class="descP">
                &nbsp;트랜지션에 대해 이해를 했다면 애니메이션에 대해서도 이해하는 것은 어렵지 않을 것이다. 여기서 애니메이션이라 하는 것은 트랜지션이 연속적으로 일어나는 것이라고 생각해도 무방할 것 같다. 애니메이션의 속성 중 가장 눈여겨 볼 것은 여러 개의 상값을 지정할 수 있다는 것과, 반복설정을 통해 자동적으로 반복이 일어
                나도록 설정이 가능하다는 것에 있다. 개략적인 설명에 대한 글이므로 자세한 속성들에 대한 내용은 <a href="http://www.w3schools.com/css/css3_animations.asp">W3CSchool<a>이나 기타 예제 사이트를 한 번쯤은 참조해 두는 것이 좋다.
              </p>
              <div class="cssBox">
                <div class="cssBoxDesc">
                  <h3>Animation</h3>
                  <div class="exAnimation"><img src="gear.png"></div>
                  <xmp>
      <div class="exAnimation">
        <img src="gear.png">
      </div>
                  </xmp>
                </div>
                <div class="cssBoxDesc">
                  <h3>CSS</h3>
                  <xmp>
  .exAnimation{
    width: 100%;
  }
  .exAnimation img {
    width: 50%;
    -webkit-animation:
            spin 4s linear infinite;
    -moz-animation:
            spin 4s linear infinite;
    animation:
            spin 4s linear infinite;
  }
  @keyframes spin {
    100% {
      transform:rotate(360deg);
      -webkit-transform: rotate(360deg);
    }
  }
  @-moz-keyframes spin {
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spin {
    100% {
      -webkit-transform: rotate(360deg);
    }
  }
                  </xmp>
                </div>
              </div>
              <p class="descP">
                &nbsp;애니메이션이 작동하는 부분을 콕 찝어 이야기 하면 <span class="attrSpan">animation: spin 4s linear infinite</span> 부분과 상호 작용하는 <span class="attrSpan">@keyframes spin</span>을 말할 수 있다. 재정의하듯 사용되는 부분은 영어를 해석만 해도 어느정도 이해가 갈 것이다. 현재 spin이라는 이름
                으로 애니메이션을 지정해 놓고, 그 부분에 대한 내용을 뒤에서 정의해놓은 것이다. 즉 <span class="classSpan">spin</span>이라는 이름은 다른이름으로 대체되어도 무관하지만 @keyframes <span class="classSpan">NAME</span>에 정황히 명시되어야 한다. 마찬가지도 크기의 변경 위치의 변경 등의 애니메이션도 같은
                방식으로 정의되어 사용될 수 있다. 이 때 쓰이는 속성들에 대해서는 라이브러리 등을 검색하여 필요할 때 사용할 수 있으면 좋겠다.
              </p>
              <p class="descP">
                &nbsp;CSS 코딩이 길어져서 조금 어리둥절해 보일 수 있지만 webkit 이라는 인용구가 들어간 부분은 과감히 무시해도 된다. 그래도 조금 설명하자면 <b>웹킷(WebKit)은 애플에서 오픈소스로 개발하고 있는 웹컨텐트(web content) 엔진 또는 웹렌더링(web rendering) 엔진이다</b> .쉽게 표현하면 웹 브라우저에서 자체적으로 제공
                하는 기능을 사용한다고 생각하면 된다. <span class="attrSpan">-moz-</span>는 <span class="classSpan">모질라 firefox</span>브라우저를 <span class="attrSpan">-webkit-</span>은 <span class="classSpan">애플의 safari</span> 그리고 아무것도 없는 것이 W3C의 표준으로 지정된 웹 또는 IE라고 해석하면 된다.
                <br>&nbsp;여기서 또 한 가지 중요한 것은 아래에 있는 코드가 마지막으로 적용되기 때문에 웹킷의 기능을 활용하고 싶다면 웹킷 코딩이 더 아래에 위치해야 한다는 것이다. 즉 위의 코딩으로 미루어 볼때 firefox 혹은 safari로 접속시 해당 브라우저의 기능을 활용하여 애니메이션을 표현할 것이다.
              </p>
            </section>
          </div>
          <div class="sectionDiv">
            <section class="articleSection">
              <h1>Canvas(손가락으로 그리기)</h1>
              <p class="descP">
                &nbsp;터치 이벤트를 기본으로 하기 때문에 <span class="classSpan">PC상에서 마우스 클릭으로는 작동하지 않는다</span>. 사용된 터치 이벤트가 총 3가지이며 이는 각각 <span class="attrSpan">touchstart</span>, <span class="attrSpan">touchmove</span>, <span class="attrSpan">touchend</span>이다. 글자에서 그
                속성을 알 수 있듯이 손가락(또는 전도체)를 대는 순간 touchstart 이벤트가 발생하고 떼는 경우 touchend 이벤트가 발동될것이다. 하지만 이벤트 설정상 touchmove 이벤트가 발동하지 않으면 canvas에는 제대로 그림이 그려지지 않을 것이다.
              </p>
              <p class="descP">
                &nbsp;현재 소지중인 모바일(G2)과 태블릿(IPad Air2)로 실험해본 결과 잘 작동하며, 해상도의 차이가 있기 때문에 해당되는 장치 버튼을 클릭시 캔버스 크기가 조정되어 100퍼센트 정확하게 그려지지는 않지만 부담스럽지 않을 정도의 정확도를 갖고 그림이 그려지는 것을 확인할 수 있을 것이다.
              </p>
              <p class="descP">
                &nbsp;코드의 내용을 자세히 보면 <span class="attrSpan">offset</span>을 처리하는 내용이 있다. 부모 레이아웃의 영향을 받아서 이동하게 되어 캔버스가 이벤트를 인식하는 범위와 화면상에 보여지는 캔버스의 위치가 다르기 때문에 그것을 조정하는 역할을 해주는 메소드를 활용한 것이다. 이 작업을 수행하지
                않으면 손가락의 위치와 다른 곳(우측하단?)에 그림이 그려지는 것을 확인할 수 있다. 유용한 정보이니 참고하도록 하자.
              </p>
              <div class="cssBox">
                <div class="cssBoxDescPC">
                  <h3>Canvas 예제</h3>
                  <canvas id="canvas01" class="canvas01" width="300px" height="300px"></canvas>
                  <input id="canvasForTablet" type="button" value="IPAD 모드">
                  <input id="canvasForMobile" type="button" value="Mobile 모드(기본)">
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
      <div id="nodeContainer" class="mainContainer">
        nodeContainer
      </div>

      <div id="lolDev" class="mainContainer">
        lolDevContainer
      </div>

    </section>

    <script src="jquery-2.2.3.min.js"></script>
    <script src="canvas.js"></script>
    <script>
      var summonerName = '화접리';
      var summonerID;
      var keyValue;
      $(document).ready(function(){
        $.ajax({
          url:'devAccess',
          type:'post',
          success: function(data) {
            var url = 'https://kr.api.pvp.net/api/lol/kr/v1.4/summoner/by-name/' + summonerName + '?api_key='+ unEncrypt(data['lol']);

            $.ajax({
                url: url,
                type:'get',
                success:function(data){
                  summonerID = data[summonerName]['id'];
                  $('#lolDev').html(JSON.stringify(data));
                }
            });
          }
        });

        $.ajax({
            url: 'http://localhost:3000/getContentAjax',
            type: 'get',
            success:function(data){
              var content = JSON.parse(data);
              $('#nodeContainer').html(content['nodeHtml']);
            }
        })
      });

      $('#introBtnAdd').click(function(){
        $('#section-base').removeClass();
        $('#section-base').addClass('section-base');
      });

      $('#introBtnRemove').click(function(){
        $('#section-base').removeClass();
      });

      $('#canvasForTablet').click(function(){
        console.log('canvasForTablet()');
        canvas01.width = 650;
        canvas01.height = 650;
      });

      $('#canvasForMobile').click(function(){
        console.log('canvasForMobile()');
        // $('#canvas01').css({'width':'300px','height':'300px'});
        canvas01.width = 300;
        canvas01.height = 300;
      });

      function unEncrypt(theText) {
          output = new String;
          Temp = new Array();
          Temp2 = new Array();
          TextSize = theText.length;
          for (i = 0; i < TextSize; i++) {
              Temp[i] = theText.charCodeAt(i);
              Temp2[i] = theText.charCodeAt(i + 1);
          }
          for (i = 0; i < TextSize; i = i+2) {
              output += String.fromCharCode(Temp[i] - Temp2[i]);
          }
          return output;
      }
    </script>
  </body>
</html>
